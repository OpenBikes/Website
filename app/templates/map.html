{% import "macros.html" as m %}
<!DOCTYPE html>
    <head>
        <meta charset='utf-8'/>
        <title>{{ city_name }} - Openbikes</title>
        <link rel="shortcut icon" href="/static/img/favicon.ico"/>
        <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no'/>
        <!-- Leaflet -->
        <script src='https://api.tiles.mapbox.com/mapbox.js/v2.1.9/mapbox.js'></script>
        <link href='https://api.tiles.mapbox.com/mapbox.js/v2.1.9/mapbox.css' rel='stylesheet'/>
        <!-- Color converter -->
        <script src="/static/js/map/color2color.min.js"></script>
        <!-- Custom button plugin -->
        <script src="/static/js/map/L.Control.Button.js"></script>
        <!-- jQuery -->
        <script src="/static/js/map/jquery.js"></script>
        <!-- Livestamp -->
        <script src="/static/js/map/moment.js"></script>
        <script src="/static/js/map/livestamp.js"></script>
        <!-- Bootstrap -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
        <!-- Locate -->
        <link href="/static/css/map/L.Control.Locate.min.css" rel="stylesheet">
        <script src="/static/js/map/L.Control.Locate.min.js"></script>
        <!-- Google polyline decoder -->
        <script src="/static/js/map/Polyline.encoded.js"></script>
        <!-- Custom style -->
        <link href="/static/css/style.css" rel="stylesheet">
        <!-- Full screen -->
        <script src='//api.tiles.mapbox.com/mapbox.js/plugins/leaflet-fullscreen/v0.0.2/Leaflet.fullscreen.min.js'></script>
        <link href='//api.tiles.mapbox.com/mapbox.js/plugins/leaflet-fullscreen/v0.0.2/leaflet.fullscreen.css' rel='stylesheet' />
        <!-- Font awesome -->
        <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" rel="stylesheet">
        <!-- Home button -->
        <link href="/static/css/map/leaflet.zoomhome.css" rel="stylesheet">
        <script src="/static/js/map/leaflet.zoomhome.min.js"></script>
        <!-- Leaflet label -->
        <link href="/static/css/map/leaflet.label.css" rel="stylesheet">
        <script src="/static/js/map/leaflet.label.js"></script>
        <!-- Map style -->
        <link href="/static/css/map/style.css" rel="stylesheet">
        <!-- DateTime picker -->
        <link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/datetimepicker/latest/DateTimePicker.min.css"></link>
        <script type="text/javascript" src="//cdn.jsdelivr.net/datetimepicker/latest/DateTimePicker.min.js"></script>
        <!-- Géolocalisation de l'addresse -->
        <script src="https://maps.googleapis.com/maps/api/js?v=3.exp&sensor=false&libraries=places"></script>
    </head>
    {% include 'includes/navigation.html' %}
    <body>
        <!-- Loading image -->
        <div class="loading"></div>
        <script type="text/javascript">
            $(window).load(function() {
                $(".loading").fadeOut("slow");
            });
        </script>
        <!-- DateTimePicker Function -->
        <script type="text/javascript">
        function setDateTime(boxId){
                // Paramètres du DateTimePicker
                $(boxId).DateTimePicker({
                    fullMonthNames : ["Janvier", "Février", "Mars", "Avril", "Mai", "Juin", "Juillet", "Aout", "Septembre", "Octobre", "Novembre", "Décembre"],
                    shortDayNames: ["Dim", "Lun", "Mar", "Mer", "Jeu", "Ven", "Sam"],
                    fullDayNames : ["Lundi","Mardi","Mercredi","Jeudi","Vendredi","Samedi","Dimanche"],
                    shortMonthNames : ["Janvier", "Février", "Mars", "Avril", "Mai", "Juin", "Juillet", "Aout", "Septembre", "Octobre", "Novembre", "Décembre"],
                    titleContentDateTime : "Choissisez la date et l'horaire de départ",
                    setButtonContent : "Appliquer",
                    clearButtonContent : "Effacer",
                    minuteInterval : 5,
                    buttonsToDisplay : ["HeaderCloseButton", "SetButton"],
                    dateTimeFormat : "dd-MM-yyyy HH:mm"
                });
             };
        </script>
        <!-- Create the map -->
        <div id="map" class="col-xs-12"></div>
        <!-- Add the routing button -->
        {% if predict == 'Yes' %}
            <div>
                <button id="toggleChoose" type="button" class="btn btn-success btn-lg" data-toggle="modal" data-target="#modalChoose">
                    <i class="fa fa-bicycle"></i>
                </button>
                {% include 'forms/choose.html' %}
                {% include 'forms/drop_bike.html' %}
                {% include 'forms/pick_bike.html' %}
                {% include 'forms/trip.html' %}
                </div>
            </div>
        {% endif %}
        <script>
            // Language pack for livestamp
            if (lang == 'fr') {
                moment.locale('fr', {
                    months : "janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre".split("_"),
                    monthsShort : "janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.".split("_"),
                    weekdays : "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
                    weekdaysShort : "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
                    weekdaysMin : "Di_Lu_Ma_Me_Je_Ve_Sa".split("_"),
                    longDateFormat : {
                        LT : "HH:mm",
                        LTS : "HH:mm:ss",
                        L : "DD/MM/YYYY",
                        LL : "D MMMM YYYY",
                        LLL : "D MMMM YYYY LT",
                        LLLL : "dddd D MMMM YYYY LT"
                    },
                    calendar : {
                        sameDay: "[Aujourd'hui à] LT",
                        nextDay: '[Demain à] LT',
                        nextWeek: 'dddd [à] LT',
                        lastDay: '[Hier à] LT',
                        lastWeek: 'dddd [dernier à] LT',
                        sameElse: 'L'
                    },
                    relativeTime : {
                        future : "dans %s",
                        past : "il y a %s",
                        s : "quelques secondes",
                        m : "une minute",
                        mm : "%d minutes",
                        h : "une heure",
                        hh : "%d heures",
                        d : "un jour",
                        dd : "%d jours",
                        M : "un mois",
                        MM : "%d mois",
                        y : "une année",
                        yy : "%d années"
                    },
                    ordinalParse : /\d{1,2}(er|ème)/,
                    ordinal : function (number) {
                        return number + (number === 1 ? 'er' : 'ème');
                    },
                    meridiemParse: /PD|MD/,
                    isPM: function (input) {
                        return input.charAt(0) === 'M';
                    },
                    meridiem : function (hours, minutes, isLower) {
                        return hours < 12 ? 'PD' : 'MD';
                    },
                    week : {
                        dow : 1,
                        doy : 4
                    }
                });
            }
        </script>



        <script type="text/javascript">
            // Load the map style
            L.mapbox.accessToken = 'pk.eyJ1IjoibGVtYXgiLCJhIjoidnNDV1kzNCJ9.iH26jLhEuimYd6vLOO6v1g';
            var map = L.mapbox.map('map', 'mapbox.outdoors', {
                maxZoom: 20,
                fullscreenControl: true,
                zoomControl: false
            })
            var layers = {
                "{{ _("Basic") }}": L.mapbox.tileLayer('mapbox.outdoors').addTo(map),
                "{{ _("Light") }}": L.mapbox.tileLayer('mapbox.light'),
                "{{ _("Dark") }}": L.mapbox.tileLayer('mapbox.dark'),
                "{{ _("Comic") }}": L.mapbox.tileLayer('mapbox.comic'),
                "{{ _("Crayon") }}": L.mapbox.tileLayer('mapbox.pencil')
            }
            L.control.layers(
                layers,
                null,
                {position: 'topleft'}
            ).addTo(map);
            // Initial location
            map.setView({{ center }}, 14);
            var zoomBar = L.Control.zoomHome();
            zoomBar.addTo(map);
            L.control.locate({
                position: 'topleft',
                drawCircle: true,
                follow: true,
                setView: true,
                keepCurrentZoomLevel: true,
                remainActive: true,
                markerClass: L.circleMarker,
                circleStyle: {},
                markerStyle: {},
                followCircleStyle: {},
                followMarkerStyle: {},
                icon: 'fa fa-child',
                iconLoading: 'fa fa-spinner fa-spin',  // class for loading icon
                circlePadding: [0, 0], // padding around accuracy circle, value is passed to setBounds
                metric: true,
                onLocationError: function(err) {alert(err.message)},  // define an error callback function
                onLocationOutsideMapBounds:  function(context) { // called when outside map boundaries
                        alert(context.options.strings.outsideMapBoundsMsg);
                },
                showPopup: true, // display a popup when the user click on the inner marker
                strings: {
                    title: "{{ _("Locate me") }}",  // title of the locate control
                    metersUnit: "{{ _("Meters") }}",
                    popup: "{{ _("This is you!") }}",
                    outsideMapBoundsMsg: "You seem located outside the boundaries of the map" // default message for onLocationOutsideMapBounds
                },
                locateOptions: {}
            }).addTo(map);
            // Add the timestamp pane
            var timestamp = L.control({position: 'bottomright'});
            timestamp.onAdd = function (map) {
                var div = L.DomUtil.create('div', 'legend');
                // Add last update information "2015-08-11T22:13:19.979650"
                div.innerHTML += '<div>{{ _("Updated") }} <b><span id="timestamp"></span></b></div>';
                return div;
            };
            timestamp.addTo(map);
            // Add the legend pane
            var legend = L.control({position: 'bottomright'});
            legend.onAdd = function (map) {
                var div = L.DomUtil.create('div', 'legend');
                var grades = [0, 0.25, 0.5, 0.75, 1];
                var labels = ["{{ _("Bikes >> Stands") }}", "{{ _("Bikes > Stands") }}", "{{ _("Bikes = Stands") }}", "{{ _("Bikes < Stands") }}", "{{ _("Bikes << Stands") }}"];
                // Add title
                div.innerHTML += '<p><div class="legend-title">{{ city_name }}</div></p>';
                // Loop through color intensities and generate a label with a colored square
                for (var i = 0; i < grades.length; i++) {
                    div.innerHTML += '<i style="background:' + getColor(grades[i], 'OPEN') + '"></i>' + labels[i] + '<br>';
                }
                return div;
            };
            legend.addTo(map);
            // Obtaining the duration since the last update
            function updateTimestamp() {
                $.getJSON('/update', {
                    city: "{{ city }}"
                }, function(data) {
                    $('#timestamp').livestamp(data.timestamp);
                });
                return false;
            };
            // Transform a value from 0 to 1 into a color
            function getColor(value, status){
                if (status == 'OPEN'){
                    var hue = (120 + value * 80).toString();
                    var saturation = '100%';
                    var luminosity = '' + (35 + value * 60)  + '%';
                    var hsl = 'hsl(' + [hue, saturation, luminosity].join(',') + ')';
                    return color2color(hsl, 'hex');
                } else {
                    return '#980000'
                }
            };
            // Marker properties
            function markerOptions(stands, total, status){
                var ratio = (stands / total).toFixed(1);
                return {
                    radius: 10,
                    fillColor: getColor(ratio, status),
                    color: '#000',
                    weight: 2.5,
                    opacity: 1,
                    fillOpacity: 0.8
                }
            };
            // Main function
            var markers = null;
            function loadMarkers(){
                $.getJSON("{{ geojson }}", function(geojson){
                    var popupOptions = {
                        'maxWidth': '500',
                        'className' : 'label',
                        'closeButton': false
                    };
                    markers = L.geoJson(geojson, {
                        onEachFeature: function (feature, layer) {
                            var properties = feature.properties
                            var name = properties.name
                            var bikes = properties.bikes
                            var stands = properties.stands
                            var status = properties.status
                            var total = bikes + stands
                            if (status == 'OPEN') {
                                if (bikes >= 2) {
                                    var bikesText = "{{ _(" bikes") }}"
                                } else {
                                    var bikesText = "{{ _(" bike") }}"
                                }
                                if (stands >= 2) {
                                    var standsText = "{{ _(" stands") }}"
                                } else {
                                    var standsText = "{{ _(" stand") }}"
                                }
                                var popupText =
                                    "<h1 align='center'>" + name + '</h1>' +
                                    '<p align=center><b>' + bikes + '</b>' + bikesText + '</p>' +
                                    '<p align=center><b>' + stands + '</b>' + standsText + '</p>';
                            } else {
                                var popupText =
                                "<h1 align='center'>" + name + '</h1>' +
                                '<p align=center>' + "{{ _("Closed") }}" + '</p>';
                            }
                            layer.bindPopup(popupText, popupOptions);
                        },
                        pointToLayer: function (feature, latlng) {
                            var properties = feature.properties
                            var name = properties.name
                            var bikes = properties.bikes
                            var stands = properties.stands
                            var status = properties.status
                            var total = bikes + stands
                            return L.circleMarker(latlng, markerOptions(stands, total, status));
                        }
                    });
                markers.addTo(map);
                })
            };
            // Regularly refresh the markers and update the delay timer
            loadMarkers();
            updateTimestamp();
            window.setInterval(function(){
                map.removeLayer(markers);
                loadMarkers();
                updateTimestamp();
            }, 60000);
            // User current position
            var geoOptions = {
                enableHighAccuracy: false,
                timeout: 5000,
                // No cache
                maximumAge: 0
            };
            var userPos = null;
            function geoSuccess(pos) {
                var userLat = pos.coords.latitude;
                var userLon = pos.coords.longitude;
                userPos = [userLat, userLon];
            };
            function geoError(err) {
                navigator.geolocation.getCurrentPosition(geoSuccess, geoError, geoOptions);
            };
            navigator.geolocation.getCurrentPosition(geoSuccess, geoError, geoOptions);
            // Routing configuration
            var searchButton = new L.Control.Button(L.DomUtil.get('toggleChoose'));
            searchButton.addTo(map);
            // Routing function
            function route(formId, mode) {
                var situation = {};
                var formArray = $(formId).serializeArray();
                for (i = 0; i < formArray.length; i++) {
                    situation[formArray[i].name] = formArray[i].value;
                }
                situation['mode'] = mode;
                situation['city'] = "{{ city }}";
                $.ajax({
                    type: "POST",
                    async: true,
                    contentType: "application/json; charset=utf-8",
                    url: "/route",
                    data: JSON.stringify(situation),
                    success: function(data) {
                        var routes = data.routes;
                        var pathColor = null;
                        for (var i = 0; i < routes.length; i++) {
                            if (routes[i]['mode'] == 'bicycling') {
                                pathColor = 'red';
                                pathIcon = '<i class="fa fa-bicycle"></i>'
                            } else {
                                pathColor = 'blue';
                                pathIcon = '<i class="fa fa-male"></i>'
                            }
                            // Decode Google polyline
                            var polyline = L.Polyline.fromEncoded(routes[i]['polyline']);
                            //var maneuvers = routes[i]['maneuvers'];
                            var nodes = polyline.getLatLngs();
                            // Extract the latitudes and longitudes into an array
                            var path = [];
                            for (var j = 0; j < nodes.length; j++) {
                                var lat = nodes[j]['lat'];
                                var lon = nodes[j]['lng'];
                                path.push([lat, lon]);
                            }
                            // Add the path to the map
                            L.polyline(path, {
                                color: pathColor,
                                weight: 10,
                                opacity: .7,
                                lineJoin: 'round'
                            }).bindLabel('<h4 style="padding-top: 8px">' + pathIcon + '</h4>').addTo(map);
                        }
                    },
                    error: function() {
                        alert("{{ _("Something went wrong :-(") }}");
                    }
                });
            };
        </script>
    </body>
</html>
